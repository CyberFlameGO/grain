/* grainc-flags --compilation-mode=runtime */

import Memory from "runtime/unsafe/memory"
import Tags from "runtime/unsafe/tags"
import WasmI32, {
  add as (+),
  mul as (*),
  xor as (^),
  shl as (<<),
} from "runtime/unsafe/wasmi32"
import WasmI64 from "runtime/unsafe/wasmi64"
import WasmF32 from "runtime/unsafe/wasmf32"
import WasmF64 from "runtime/unsafe/wasmf64"

//
// For performance reasons, all functions in this module do not
// decRef their arguments. Consequently, callers should not incRef them before calling.
//

/**
 * Allocates a new Grain array.
 *
 * @param {WasmI32} numElts The number of elements to be contained in this array
 * @returns The pointer to the array
 */
export primitive allocateArray: WasmI32 -> WasmI32 = "@allocate.array"

/**
 * Allocates a new Grain tuple.
 *
 * @param {WasmI32} numElts The number of elements to be contained in this tuple
 * @returns The pointer to the tuple
 */
export primitive allocateTuple: WasmI32 -> WasmI32 = "@allocate.tuple"

/**
 * Allocates a new Grain bytes.
 *
 * @param {WasmI32} size The number of bytes to be contained in this buffer
 * @returns The pointer to the bytes
 */
export primitive allocateBytes: WasmI32 -> WasmI32 = "@allocate.bytes"

/**
 * Allocates a new Grain string.
 *
 * @param {WasmI32} size The size (in bytes) of the string to allocate
 * @returns The pointer to the string
 */
export primitive allocateString: WasmI32 -> WasmI32 = "@allocate.string"

/**
 * Creates a new Grain string containing the given character
 *
 * @param {WasmI32} c The character for which to allocate a string
 * @returns The pointer to the string
 */
export let singleByteString = c => {
  let str = Memory.malloc(9n)

  WasmI32.store(str, Tags._GRAIN_STRING_HEAP_TAG, 0n)
  WasmI32.store(str, 1n, 4n)
  WasmI32.store8(str, c, 8n)

  str
}

/**
 * Allocates a new Grain char.
 *
 * @returns The pointer to the char
 */
export primitive allocateChar: () -> WasmI32 = "@allocate.char"

// INT32/INT64

/**
 * Allocates a new Int32.
 *
 * @returns
 */
export primitive allocateInt32: () -> WasmI32 = "@allocate.int32"

/**
 * Allocates a new Int32 with a prepopulated value
 * @param value The value to store
 */
export primitive newInt32: WasmI32 -> WasmI32 = "@new.int32"

/**
 * Allocates a new Int64.
 *
 * @returns
 */
export primitive allocateInt64: () -> WasmI32 = "@allocate.int64"

/**
 * Allocates a new Int64 with a prepopulated value
 * @param value The value to store
 */
export primitive newInt64: WasmI64 -> WasmI32 = "@new.int64"

// FLOATS

/**
 * Allocates a new Float32.
 *
 * @returns
 */
export primitive allocateFloat32: () -> WasmI32 = "@allocate.float32"

/**
 * Allocates a new Float32 with a prepopulated value
 * @param value The value to store
 */
export primitive newFloat32: WasmF32 -> WasmI32 = "@new.float32"

/**
 * Allocates a new Float64.
 *
 * @returns
 */
export primitive allocateFloat64: () -> WasmI32 = "@allocate.float64"

/**
 * Allocates a new Float64 with a prepopulated value
 * @param value The value to store
 */
export primitive newFloat64: WasmF64 -> WasmI32 = "@new.float64"

// RATIONALS

/**
 * Allocates a new Rational.
 *
 * @returns
 */
export primitive allocateRational: () -> WasmI32 = "@allocate.rational"

/**
 * Allocates a new Rational with a prepopulated value
 * @param value The value to store
 */
export primitive newRational: (WasmI32, WasmI32) -> WasmI32 = "@new.rational"

/**
 * Load a value from an ADT.
 *
 * @export
 * @param {WasmI32} ptr Untagged pointer to the ADT
 * @param {WasmI32} idx Index (from zero) of the item
 * @returns The value located at the index
 */
export let loadAdtVal = (ptr, idx) => {
  WasmI32.load(ptr + idx * 4n, 20n)
}

/**
 * Load the (tagged) variant of an ADT.
 *
 * @export
 * @param {WasmI32} ptr Untagged pointer to the ADT
 * @returns The (tagged) ADT variant id
 */
export primitive loadAdtVariant: WasmI32 -> WasmI32 = "@adt.load_variant"

/**
 * Load an untagged string's size.
 *
 * @export
 * @param {WasmI32} ptr Untagged pointer to the string
 * @returns The string size (in bytes)
 */
export primitive stringSize: WasmI32 -> WasmI32 = "@string.size"

/**
 * Load an untagged Bytes' size.
 *
 * @export
 * @param {WasmI32} ptr Untagged pointer to the Bytes
 * @returns The string size (in bytes)
 */
export primitive bytesSize: WasmI32 -> WasmI32 = "@bytes.size"

export let tagSimpleNumber = x => {
  WasmI32.toGrain(x << 1n ^ 1n): Number
}
